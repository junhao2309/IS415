---
title: "Hands-On Exercise 10: Modelling Geographical Accessibility"
date: "19 March 2023"
date-modified: "`r Sys.Date()`"
number-sections: true
format: html
execute: 
  echo: true
  eval: true
  warning: false
editor: visual
---

# Setting the Scene

In this hands-on exercise, we will learn how to model geographical accessibility.

These are the learning outcome from this exercise:

-   Computerise accessibility measure by using:

    1.  Hansen's potential model
    2.  Spatial Accessibility Measure (SAM)

-   Visualise the accessibility measures by using tmap and ggplot2 packages

## Data used in this Exercise

-   `MP14_SUBZONE_NO_SEA_PL`: URA Master Plan 2014 subzone boundary GIS data.
    This data set is downloaded from data.gov.sg.

-   `hexagons`: A 250m radius hexagons GIS data.
    This data set was created by using [*st_make_grid()*](https://r-spatial.github.io/sf/reference/st_make_grid.html) of sf package.
    It is in ESRI shapefile format.

-   `ELDERCARE`: GIS data showing location of eldercare service.
    [This data](https://data.gov.sg/dataset/eldercare-services) is downloaded from data.gov.sg.
    There are two versions.
    One in ESRI shapefile format.
    The other one in Google kml file format.
    For the purpose of this hands-on exercise, ESRI shapefile format is provided.

-   `OD_Matrix`: a distance matrix in csv format.
    There are six fields in the data file.
    They are:

    -   `origin_id`: the unique id values of the origin (i.e. `fid` of hexagon data set.),

    -   `destination_id`: the unique id values of the destination (i.e. `fid` of `ELDERCARE` data set.),

    -   `entry_cost`: the perpendicular distance between the origins and the nearest road),

    -   `network_cost`: the actual network distance from the origin and destination,

    -   `exit_cost`: the perpendicular distance between the destination and the nearest road), and

    -   `total_cost`: the summation of `entry_cost`, `network_cost` and `exit_cost`.

All the values of the cost related fields are in **metres**.

## Load packages in

```{r}
pacman::p_load(tmap, SpatialAcc, sf, 
               ggstatsplot, reshape2,
               tidyverse)
```

# Data Wrangling

## Geospatial Data

### Import Geospatial Data

```{r}
mpsz <- st_read(dsn = "data/geospatial", 
                layer = "MP14_SUBZONE_NO_SEA_PL")
```

```{r}
hexagons <- st_read(dsn = "data/geospatial", 
                    layer = "hexagons") 
```

```{r}
eldercare <- st_read(dsn = "data/geospatial", 
                     layer = "ELDERCARE") 
```

### Update CRS information

We have to ensure ESPG code for all spatial data are in 3414.

```{r}
mpsz <- st_transform(mpsz, 3414)
eldercare <- st_transform(eldercare, 3414)
hexagons <- st_transform(hexagons, 3414)
```

We can then check their crs by using st_crs() of sf package.

```{r}
st_crs(mpsz)
```

### Cleaning and updating attribute fields of geospatial data

```{r}
eldercare <- eldercare %>%
  select(fid, ADDRESSPOS) %>%
  mutate(capacity = 100)
```

```{r}
hexagons <- hexagons %>%
  select(fid) %>%
  mutate(demand = 100)
```

A constant value of 100 is used for this practise.
However, in practice, actual demand of the hexagon and capacity of the eldercare centre should be used.

## Aspatial Data

### Importing Distance Matrix

```{r}
ODMatrix <- read_csv("data/aspatial/OD_Matrix.csv", 
                     skip = 0)
```

### Tidying distance matrix

We can see that the imported data organises the distance matrix columnwise.

```{r}
glimpse(ODMatrix)
```

We will proceed to wrangle the data such that rows represent origins and columns represent destination.

The code chunk below uses spread() of tidyr package to transform the ODMatrix from thin format into fat format.

```{r}
distmat <- ODMatrix %>%
  select(origin_id, destination_id, total_cost) %>%
  spread(destination_id, total_cost)%>%
  select(c(-c('origin_id')))
```

We can then convert unit f measurement from metre to kilometre

```{r}
distmat_km <- as.matrix(distmat/1000)
```

# Modelling and Visualising Accessibility 

::: panel-tabset
## Hansen Method

Step 1: The code chunk below calculates Hansen\'s accessibility using *ac()* of **SpatialAcc** and *data.frame()* to save the output in a data frame called `acc_Handsen`.

Note: Argument of ac(), family = "Hansen"

Step 2: You will notice that the default field name is messy by running glimpse() from the dplyr package.
For easy referencing, we will rename it to accHansen

Step 3: Next, we will convert the data table into a tibble format

Step 4: Lastly, we will bind columns of hexagons and acc_Hansen by using the bind_cols of dplyr package.

```{r}
# Step 1
acc_Hansen <- data.frame(ac(hexagons$demand,
                            eldercare$capacity,
                            distmat_km, 
                            d0 = 50,
                            power = 2, 
                            family = "Hansen"))
# Step 2
colnames(acc_Hansen) <- "accHansen"
# Step 3
acc_Hansen <- as_tibble(acc_Hansen)
# Step 4
hexagon_Hansen <- bind_cols(hexagons, acc_Hansen)
```

### Visualising Hansen's accessibility

#### Extracting map extend

The code chunk below extract the extend of hexagons sf dataframe by using st_bbox() of sf package.

```{r}
mapex <- st_bbox(hexagons)
```

The code chunk below uses a collection of mapping functions of tmap package to create a high cartographic quality accessibility to eldercare centres in Singapore.

```{r}
tmap_mode("plot")
tm_shape(hexagon_Hansen,
         bbox = mapex) + 
  tm_fill(col = "accHansen",
          n = 10,
          style = "quantile",
          border.col = "black",
          border.lwd = 1) +
tm_shape(eldercare) +
  tm_symbols(size = 0.1) +
  tm_layout(main.title = "Accessibility to eldercare: Hansen method",
            main.title.position = "center",
            main.title.size = 2,
            legend.outside = FALSE,
            legend.height = 0.45, 
            legend.width = 3.0,
            legend.format = list(digits = 6),
            legend.position = c("right", "top"),
            frame = TRUE) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar(width = 0.15) +
  tm_grid(lwd = 0.1, alpha = 0.5)
```

### Statistical graphic visualisation

Firstly, we need to add the planning region field into *haxegon_Hansen* simple feature data frame by using the code chunk below.

```{r}
hexagon_Hansen <- st_join(hexagon_Hansen, mpsz, 
                          join = st_intersects)
```

Next we will use ggplot() to plot the distribution by boxplot

```{r}
ggplot(data=hexagon_Hansen, 
       aes(y = log(accHansen), 
           x= REGION_N)) +
  geom_boxplot() +
  geom_point(stat="summary", 
             fun.y="mean", 
             colour ="red", 
             size=2)
```

## KD2SFCA Method

### Computing KD2SFCA's accessibility

Step 1: The code chunk below calculates KD2SFCA\'s accessibility using *ac()* of **SpatialAcc** and *data.frame()* to save the output in a data frame called `acc_KD2SFCA`.
\
Note: Argument of ac(), family = "KD2SFCA"

Step 2: You will notice that the default field name is messy by running glimpse() from the dplyr package.
For easy referencing, we will rename it to accKD2SFCA

Step 3: Next, we will convert the data table into a tibble format

Step 4: Lastly, we will bind columns of hexagons and acc_KD2SFCA by using the bind_cols of dplyr package.

```{r}
acc_KD2SFCA <- data.frame(ac(hexagons$demand,
                            eldercare$capacity,
                            distmat_km, 
                            d0 = 50,
                            power = 2, 
                            family = "KD2SFCA"))

colnames(acc_KD2SFCA) <- "accKD2SFCA"
acc_KD2SFCA <- as_tibble(acc_KD2SFCA)
hexagon_KD2SFCA <- bind_cols(hexagons, acc_KD2SFCA)
```

### Visualising KD2SFCA's accessibility

#### Extracting map extend

The code chunk below extract the extend of hexagons sf dataframe by using st_bbox() of sf package.

```{r}
mapex <- st_bbox(hexagons)
```

The code chunk below uses a collection of mapping functions of tmap package to create a high cartographic quality accessibility to eldercare centres in Singapore.

```{r}
tmap_mode("plot")
tm_shape(hexagon_KD2SFCA,
         bbox = mapex) + 
  tm_fill(col = "accKD2SFCA",
          n = 10,
          style = "quantile",
          border.col = "black",
          border.lwd = 1) +
tm_shape(eldercare) +
  tm_symbols(size = 0.1) +
  tm_layout(main.title = "Accessibility to eldercare: KD2SFCA method",
            main.title.position = "center",
            main.title.size = 2,
            legend.outside = FALSE,
            legend.height = 0.45, 
            legend.width = 3.0,
            legend.format = list(digits = 6),
            legend.position = c("right", "top"),
            frame = TRUE) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar(width = 0.15) +
  tm_grid(lwd = 0.1, alpha = 0.5)
```

### Statistical graphic visualisation

Firstly, we need to add the planning region field into *haxegon_KD2SFCA* simple feature data frame by using the code chunk below.

```{r}
hexagon_KD2SFCA <- st_join(hexagon_KD2SFCA, mpsz, 
                          join = st_intersects)
```

Next we will use ggplot() to plot the distribution by boxplot

```{r}
ggplot(data=hexagon_KD2SFCA, 
       aes(y = accKD2SFCA, 
           x= REGION_N)) +
  geom_boxplot() +
  geom_point(stat="summary", 
             fun.y="mean", 
             colour ="red", 
             size=2)
```

## Spatial Accessibility Measure (SAM)

Step 1: The code chunk below calculates SAM's accessibility using *ac()* of **SpatialAcc** and *data.frame()* to save the output in a data frame called `acc_SAM`.
\
Note: Argument of ac(), family = "SAM"

Step 2: You will notice that the default field name is messy by running glimpse() from the dplyr package.
For easy referencing, we will rename it to accSAM.

Step 3: Next, we will convert the data table into a tibble format

Step 4: Lastly, we will bind columns of hexagons and acc_SAM by using the bind_cols of dplyr package.

```{r}
acc_SAM <- data.frame(ac(hexagons$demand,
                         eldercare$capacity,
                         distmat_km, 
                         d0 = 50,
                         power = 2, 
                         family = "SAM"))

colnames(acc_SAM) <- "accSAM"
acc_SAM <- tbl_df(acc_SAM)
hexagon_SAM <- bind_cols(hexagons, acc_SAM)
```

### Visualising SAM\'s accessibility

#### Extracting map extend

The code chunk below extract the extend of hexagons sf dataframe by using st_bbox() of sf package.

```{r}
mapex <- st_bbox(hexagons)
```

The code chunk below uses a collection of mapping functions of tmap package to create a high cartographic quality accessibility to eldercare centres in Singapore.

```{r}
tmap_mode("plot")
tm_shape(hexagon_SAM,
         bbox = mapex) + 
  tm_fill(col = "accSAM",
          n = 10,
          style = "quantile",
          border.col = "black",
          border.lwd = 1) +
tm_shape(eldercare) +
  tm_symbols(size = 0.1) +
  tm_layout(main.title = "Accessibility to eldercare: SAM method",
            main.title.position = "center",
            main.title.size = 2,
            legend.outside = FALSE,
            legend.height = 0.45, 
            legend.width = 3.0,
            legend.format = list(digits = 3),
            legend.position = c("right", "top"),
            frame = TRUE) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar(width = 0.15) +
  tm_grid(lwd = 0.1, alpha = 0.5)
```

### Statistical graphic visualisation

Now, we are going to compare the distribution of SAM accessibility values by URA Planning Region.

Firstly, we need to add the planning region field into *hexagon_SAM* simple feature data frame by using the code chunk below.

```{r}
hexagon_SAM <- st_join(hexagon_SAM, mpsz, 
                       join = st_intersects)
```

Next, ggplot() will be used to plot the distribution by using boxplot graphical method.

```{r}
ggplot(data=hexagon_SAM, 
       aes(y = accSAM, 
           x= REGION_N)) +
  geom_boxplot() +
  geom_point(stat="summary", 
             fun.y="mean", 
             colour ="red", 
             size=2)
```
:::
